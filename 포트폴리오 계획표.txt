1일 1프로젝트 // C++이든 C#이든 C든 다른 언어든간에

0506. 프로젝트 시작
1.계획 수립 - 쩜비 서바이벌 디펜스
2.캐릭터 간단한 walk, run, 카메라 상하 회전, 캐릭터 회전 등 구현
3.1인칭 FPS 구현
4.크로스헤어(조준점) 간단하게 표현

0507.
1.총구 화염 및 총알 발사 
2.좀비 프리팹 만들기

오늘의 C++ 알고리즘 문제 : 2438, 별 찍기 -1
-----------------------------------------------------
#include <iostream>

using namespace std;

// i만큼 *을 찍고 개행해서 n까지 찍어라.

int main()
{
	int n;
	cin >> n;

	for (int i = 1; i <= n; i++)
	{
		for (int j = 1; j <= i; j++)
		{
			cout << "*";
		}
		cout << endl;
	}

	return 0;
}
-----------------------------------------------------

0508. 
1. 샘플 맵 구성 // 어느정도 terrain에 대해 알아봤다.
2. 플레이어 애니메이션 찾기 및 적용 // 실패 다음주에 이어서
3. 작은 게임 하나 만들어보기 // 리지드바디를 이용하면 오브젝트를 밀수 있다.
ex)플레이어를 조작해 큐브같은 3d오브젝트를 밀거나 당겨서 스테이지를 클리어하는 형식의 퍼즐 게임

오늘의 알고리즘 문제 : 10818, 최소, 최대값 출력(배열)
-----------------------------------------------------
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	int n;					// 테스트 케이스의 개수
	cin >> n;			  		// 테스트 케이스 입력		int* num = new int[n];			// 가변 배열 동적 할당


	for (int j = 0; j < n; j++)			// 배열에 n만큼 입력
		cin >> num[j];				

	int small = num[0];		// 최솟값 변수에 num 배열의 첫 번째 값을 대입
	int large = num[0];		// 최댓값 변수에 num 배열의 첫 번째 값을 대입

	for (int i = 0; i < n; i++)		
	{
	// 작동 원리는 이렇다
	// 첫번째 자리와 num[i] 즉 0부터 n까지의 수를 계속 비교하면서
	// 최솟값 함수인 min 함수는 배열에서 가장 작은 값을 반환하고
	// 최댓값 함수인 max 함수는 배열에서 가장 큰 값을 반환하게 된다.
	small = min(small, num[i]);	// 배열의 첫번째 값과 배열 전체를 비교
	large = max(large, num[i]);	// 배열의 첫번째 값과 배열 전체를 비교
	}

	cout << small << " " << large; // 최솟값과 최댓값을 출력
	
	delete[] num;
	// 동적 할당한 가변 배열은 delete 함으로써 메모리 누수를 방지한다.

	return 0;

}
-----------------------------------------------------

0511.
1. 샘플맵 건물 구축 및 완성 // 다음에..
2. 플레이어 애니메이션 적용 // 애니메이션 넣을 필요 없음
3. 플레이어 총 좀 더 자세히 구현하기 // 다음에..
+4. 크로스헤어 설정 및 애니메이션 // 애니메이션은 보강이 좀더 필요함
+5. HUD 설정 // 총알 HUD를 만듬. 추후에 수정할것

오늘의 알고리즘 문제 : 10871, X보다 작은 수
-----------------------------------------------------
#include <iostream>

using namespace std;

int main()
{
	int n, x;		// N개의 배열 인자, 기준점 X
	cin >> n >> x;	// N,X 입력
	
	int *a = new int [n]; // A 가변 배열에 N개 인자 할당
	for(int i = 0; i<n; i++) // i를 n만큼 반복
	{
		cin >> a[i];  // a 배열에 순서대로 수 입력
		if(a[i] < x)    // x보다 a의 배열 인자가 작을 때
		{
			cout << a[i] << " "; // 현재 a의 배열 인자를 출력
		}
	}
	
	delete[] a;

	return 0;
}
-----------------------------------------------------

0512.
1. 케이디 영상 보면서 쩜비 서바이벌 순서대로 구축해나가기
2. 지형 LOD 재설정(풀이 시야에 있는데 안보이는 문제, 나무가 멀리서 발광하는 문제)

오늘의 알고리즘 문제 : 2562, 최댓값
-----------------------------------------------------
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	int a[9] = {};		// 9칸의 배열을 생성 및 초기화
	int num;			// 최댓값을 저장할 정수 변수 생성

	for (int i = 0; i < 9; i++)	// 배열 전체를 반복해서 입력해줄 반복문
	{
		cin >> a[i];
	}
	num = a[0];		// 입력을 마치고 num 변수에 0번째 값을 대입
	for (int j = 0; j < 9; j++)	// 배열을 비교하기 위해서 다시 한번 반복문
	{
		num = max(num, a[j]); // 최댓값을 찾아줄 algorithm 라이브러리의 
	}		         // max 함수를 이용해서 num 변수에 최댓값 저장
	cout << num << "\n";	// 최댓값 우선 출력
	for (int k = 0; k < 9; k++)	// 배열 전체를 비교하기 위해 다시 반복문
	{
		if (num == a[k])	// 최댓값과 같은 정수를 가지고 있는 배열을
		{		// 검색하고 찾았다면
			cout << k+1;  // 해당 배열이 몇번째 칸에 있는지 출력 
			break;	// 이후로는 의미없는 반복이 되므로 반복문 탈출
		}
	}
	return 0;
}

----------------------------------------------------- // 함수 없이 최댓값 구하는 방법
#include <iostream>

using namespace std;

int main()
{
	int a[9];			// 배열 생성 및 초기화
	int num = 0, k;		// 최댓값 넣어줄 변수 생성
	for(int i=0; i <9; i++)	// 반복문
	{			
		cin >> a[i];	// 배열 입력
		if(num < a[i])	// num = 0; 이 입력된 배열보다 작을 때
		{		
			num = a[i];	// num 변수에 해당 정수를 대입
			k = i;		// k 변수에 몇 번째 칸인지 기억 저장
		}
	}
	cout << num << endl << k+1;	// 최종적으로 최댓값과 칸을 찾아낾
}
-----------------------------------------------------

0513.
1. 케이디 영상 보면서 쩜비 서바이벌 순서대로 구축해나가기
2. 지형 LOD 재설정 및 건물 구축

오늘의 알고리즘 문제 : 2577, 숫자의 개수
-----------------------------------------------------
#include <iostream>

using namespace std;

int main()
{
	int a[3] = {};		// A,B,C의 입력값을 저장할 배열
	int single[10] = {};		// 각 자릿수의 숫자를 저장할 배열
	int total = 0;		// A*B*C를 저장할 변수
	for(int i = 0; i < 3; i++)	
	{
		cin >> a[i];	// A, B, C 입력
	}
	total = a[0] * a[1] * a[2]; 	// A * B * C 저장
	while(total > 0)		// total이 0이 될때까지 반복
	{
		// 10으로 나누면 일의 자리부터 나머지가 생기는데
		// 나머지만큼의(0~9) 배열에 +1 시켜줌으로써 0~9까지의
		// 숫자의 개수를 배열 순번에 맞게 저장한다.
		single[total % 10] += 1;	// total % 10 의 배열에 1씩 추가한다.
		total /= 10;	// total을 10으로 나누어서 자릿수를 계산한다
	}
	for(int i = 0; i <10; i++)
		cout << single[i] << endl; // 자릿수 출력
	return 0;
}
-----------------------------------------------------

0514.
1. 스크립트 간의 상속 에러 수정 // 무기 교체와 상속 문제는 케어했지만 AK와 M4를 교체하는 데에 있어서 HUD의 변경문제는 아직 해결하지 못했다. 그 외 짜잘짜잘한 버그들이 있는것 같다. 일단은 나중에 바꾸도록 할것이다.
2. 지형 LOD 재설정 // 터레인의 나무나 풀같은것들은 LOD가 자동적으로 설정되어있는듯 하다. 일단은 이상태로 유지하고 다른 건물들부터 구축할 예정이다.

오늘의 알고리즘 문제 : 없음, API 좌표에 관해 분석했음
-----------------------------------------------------
1. Win32 API에서 사각형을 그리는 RECT 구조체는 hdc, left, top, right, bottom의 인자로 구성되어 있고 우리는 사각형을 그리되 중심을 찾아서 그릴 수 있도록 배웠다.
2. 오늘 API 수업에서 배운 것중 가장 기억에 남는 것은 선과 플레이어의 충돌,
박스와 박스간의 충돌이다.
3. 사각형끼리 충돌할때에는 IntersectRect(&교집합을넣을 사각형의주소, A(사각형), B(사각형))함수로 이렇게 인자가 구성되어있다. 각 도형의 교집합을 구하는 함수인데 교집합이 생겼다는 것은 충돌이 일어났다는 뜻이므로 이를 응용해서 사각형 간의 충돌을 구현할 수 있더라.
4. 선과 박스의 충돌은 위와 같이 함수가 없기 때문에 별도의 수학 공식을 이용해서 구현해야했다. 어렵다.
----------------------------------------------------

0515.
1. 건물 및 터레인 꾸미기				// 나무, 잔디만 수정..
2. 좀비 스크립트 수정하기(공격도 가능하게 한다던가)	// 실패!!

오늘의 알고리즘 문제: 1110, 더하기 사이클
----------------------------------------------------
#include <iostream>

using namespace std;

int main()
{
	int n = 0, a = 0, b = 0, c = 0, k = 0, count = 0;
	cin >> n;

	k = n;

	while (true)
	{	
		// 십의 자리
		if (k < 10)
			a = 0;
		else
			a = (k % 100) / 10;
		
		// 일의 자리
		b = (k % 10);
		
		// 십의 자리 + 일의 자리
		c = a + b;
		
		// 일의 자리 * 10 + C의 일의 자리
		k = (b*10) + (c % 10);

		count++;				// 사이클 횟수 증가

		if (k == n)			// k가 n과 같을 때
		{
			cout << count;		// 사이클 횟수 출력
			break;			// 반복문 탈출
		}
	}

	return 0;
}

// 자릿수를 물어보는 문제들은 이렇게 풀면된다.
// 일의 자리 = Number % 10
// 십의 자리 = (Number % 100) / 10;
// 등등 자릿수가 올라갈 때마다 0이 하나씩 붙는다고 보면 된다!!
----------------------------------------------------

0518.
1. 인벤토리 제작해보기
2. 시네머신이나 카메라워킹 배워보기

오늘의 알고리즘 문제 : 10817, 세 수
----------------------------------------------------
#include <iostream>

using namespace std;

int main()
{
	int a, b, c;
	cin >> a >> b >> c;

	if (a > b)
		if (a > c)	// a가 b와 c보다 클 경우 (가장 클 경우)
			if (b > c)
				cout << b;
			else
				cout << c;
		else
			cout << a;
	else
		if (a < c)	// a가 b와 c보다 작을 경우 (가장 작을 경우)
			if (b < c)
				cout << b;
			else
				cout << c;
		else
			cout << a;
	return 0;
}

// 세 수 사이의 중간값을 구하기 위해서는
// 세 수 중 하나의 값을 기준값으로 잡고 그 수의 크고 작음에 따라
// 최솟값과 최댓값을 나누어 중간값을 구할 수 있다.
----------------------------------------------------

0519.
1. 시네머신이나 만져보기 // 버츄얼 카메라, 돌리 트랙, LookAt 등등
2. 게임 구체적인 틀 잡기(게임의 방식)

오늘의 알고리즘 문제 : 없음.
----------------------------------------------------

----------------------------------------------------
0520.
1. 스왑할때 HUD(그림, 총알개수) 변경
변경해야할 점.
가. HUD의 비가시화 : 처음 시작할 때 HUD를 끄고 시작합니다. 총을 들고 있을 때에만 HUD를 화면에 표시합니다. // 성공, 하지만 총알이 실시간으로 업데이트되지 않음.
Update문에 없어서 그런듯함. 추후에 수정 예정
나. 스왑 시 각 무기에 맞는 HUD를 소환합니다.
// 성공, 문제점은 상동
2. 인벤토리 장비창 구현해보기
구현할 시 필요한 것
가. Drag And Drop을 이용해서 인벤토리에서 장비창으로 옮겨 장착이 가능하도록 하기
나. 게임을 시작했을 때에는 아무런 물건 없이 시작하게 되고 아이템을 줍게 되면 바로 장착이 가능하도록 만들것.
다. 장비의 순서는 나이프, 총, 총2, 도끼로 4개만 들고 다닐 수 있음.
라. 장비창이 꽉차면 자동적으로 인벤토리에 쌓이게 할것.

오늘의 알고리즘 문제 : 3052, 나머지
----------------------------------------------------
#include <iostream>

using namespace std;

int main()
{
	int a[10] = {};		// 나눌 숫자를 저장하는 배열
	int b[42] = {};		// 숫자를 42로 나눈 나머지를 저장하는 배열
	int c = 0;			// 서로 다른 나머지의 갯수를 저장하는 변수
	for (int i = 0; i < 10; i++)	// a 배열을 입력해주는 반복문
	{
		cin >> a[i];	// 배열 순차적 입력
		
		b[a[i] % 42] = 1;	// a배열을 42로 나눈 값을 b 배열에 1로
				// 치환해 입력
	}

	for (int j = 0; j < 42; j++)	// b 배열 반복
	{
		if (b[j] == 1)	// b 배열 중 1이 있는 원소배열을 찾음
			c += 1;	// 서로 다른 값들의 갯수를 1씩 추가 입력
	}

	cout << c;		// 서로 다른 나머지의 개수를 출력

	return 0;
}
----------------------------------------------------

0521.
1. 몬스터(적) AI 구현	// AI는 구현했으나 아쉬운 부분이 많음
2. 지형 구현하기		// 실패

오늘의 알고리즘 문제 : 2439, 별 찍기 -2
----------------------------------------------------
#include <iostream>

using namespace std;

int main()
{
	int n;	// 별의 갯수를 입력하는 변수
	cin >> n;	// 갯수 입력

	for (int i = 0; i < n; i++)	// i가 n까지 반복, 행은 N번까지 반복
	{
	// 행의 빈칸은 공백으로 취한다.
	// 먼저 n의 갯수 만큼의 공백을 주고 마지막 칸에 별을 그려야한다.
		for (int j = 0; j < n; j++)	// j가 n까지 반복, 열도 N번까지 반복
		{
			// 최종적으로 행렬의 크기는 NxN이 됨.
			// 행의 마지막 열부터 별을 그리는 방식.
			
			if (i + j < n - 1)// i+j가 n-1보다 작을 때 빈칸으로 채우기
				cout << " ";
			else if (i + j >= n - 1)// i+j가 n-1보다 클 때 별로 채우기
				cout << "*";
			// 0 0 0 0 1
			// 0 0 0 1 1
			// 0 0 1 1 1
			// 0 1 1 1 1
			// 1 1 1 1 1
		}
		cout << endl;
	}
	return 0;
}
---------------------------------------------------- 

0521.
1. 몬스터 피격 및 추적 및 공격
2. 지형 구축

오늘의 알고리즘 문제 : 5543, 상근날드
---------------------------------------------------- 
#include <iostream>

using namespace std;

int main()
{
int s, j, h, c, d, n = 0;		// 상덕, 중덕, 하덕, 콜라, 사이다 순
cin >> s >> j >> h >> c >> d;	// 상덕, 중덕, 하덕, 콜라, 사이다 순서대로 입력

	if (s < j && s < h)		// 상덕버거가 제일 쌀 때
		n = s;
	else if (j < s && j < h)        // 중덕버거가 제일 쌀 때
		n = j;
	else              	            // 하덕버거가 제일 쌀 때
		n = h;

	if (c > d)			// 사이다가 콜라보다 쌀 때
		n += d;			        
	else if (d > c)		// 콜라가 사이다보다 쌀 때
		n += c;		        
	else if (d == c)                 // 가격이 같을 때
		n += c;

	cout << n-50;                  // 세트메뉴 50원 차감해주고 출력

	return 0;
}

// 조건문을 어떻게 활용해야할지 조금 생각해보게 되는 문제였다.
// 논리적으로 조건을 걸어주지 않으면 코드가 난잡해지는 경우가 생길 수 있으니
// 항상 주의할것
---------------------------------------------------- 

0525.
1. 플레이어 애니메이션 
2. 건물 에셋 구하기 및 건물 구축
3. 인벤토리 세팅

오늘의 알고리즘 문제 : 2523, 별 찍기 - 13
----------------------------------------------------
#include <iostream>

using namespace std;

int main()
{
	int n;		// 별의 최고차수를 정하는 변수
	cin >> n;		// 최고차수 입력

	for (int i = 0; i < 2 * n - 1; i++)	// 2차 반복문에서의 i는 행렬의 행
	{
		for (int j = 0; j < n; j++)	// j는 행렬의 열
		{
		// i에서 j를 뻈을 때 0보다 같거나 작고 그 수가 n보다 작을 경우에
			if (i - j >= 0 && i - j < n)
				cout << "*";	// 별을 출력합니다.
											// 콘솔상의 좌표계에서는 왼쪽 위를 0으로 규정하며
											// 좌표계상에서 좌표끼리의 규칙을 이용하여 풀이했습니다.	
		// 1 0 0 0 0
		// 1 1 0 0 0
		// 1 1 1 0 0
		// 1 1 0 0 0
		// 1 0 0 0 0
		}
		cout << endl;
	}
	return 0;
}
----------------------------------------------------

0526.
1. 플레이어 애니메이션 // 구현하려고 했으나 무기 포지션을 일일이 다 맞춰줘야하고 그게 또 가능할거란 보장이 없었기 때문에 포기했음. 그러나 Axe 애니메이션을 수작업으로 만들수 있게 됨. 아마 나이프, 총들도 이것처럼 조금 노다가지만 위의 작업보다는 괜찮게 수정이 될거라 생각함.

오늘의 알고리즘 문제 : 1546, 평균
----------------------------------------------------
#include <iostream>
#include <algorithm>

using namespace std;

int main()
{
	int n;		// 시험친 과목의 개수
	cin >> n;	// 과목 갯수 입력

	float *Num = new float[n];	// n번에 대한 가변 배열
	float total = 0;		// 총합
	float aver = 0;		// 평균

	for (int i = 0; i < n; i++)	// 반복문으로 배열 순차 입력
		cin >> Num[i];

	float m= Num[0];	// 최댓값을 구하기 위한 배열의 첫번째 값 대입

	for (int j = 0; j < n; j++)		// 최댓값 찾기
		m = max(m, Num[j]);	// max 알고리즘

	for (int k = 0; k < n; k++)		
	{
	    Num[k] = Num[k] / m * 100;  // 모든 점수를 점수/최댓값 * 100으로 변환  
	    total += Num[k];         	     // 변환한 점수를 total에 n번만큼 추가시킴
	}

	aver = float(total / n);        // 평균을 float으로 구하고

	cout << aver;                  // 평균 최종 출력

	return 0;
}
----------------------------------------------------

0527.
// 결석 -- 병원

0528.
// 결석

0529.
1. 무기 애니메이션 구현 // 
2. 무기마다 사운드를 좀 색다르게 구현해보기
ex)도끼는 묵직하고 거칠게, 나이프는 날카롭고 가볍게 등

오늘의 알고리즘 문제 : 없음.
----------------------------------------------------
----------------------------------------------------

0601.
1. 게임 씬 구성하기	 // 성공
ex)게임 시작시 첫화면 -> 로딩화면 -> 게임 시작 
2. 지역(지형) 추가하기 // 실패
3. 게임을 아예 갈아 엎었다.
돌격 소총을 삭제하고 저격총을 추가했으며 GunController 하나로 총을 제어할 수
있도록 했다. 여러가지 자잘자잘한 버그들이 많다. 내일 고쳐야겠다.
스토리를 개선했으며 최대한 이 방향으로 나아가겠다.

오늘의 알고리즘 문제 : 없음.
----------------------------------------------------
----------------------------------------------------

0602.
1. 스크립트 안정화
// 인벤토리를 퀵슬롯 형식으로 새롭게 단장했으며 소총으로 조준시 애니메이션을 추가했고 부자연스러웠던 스코프 UI를 수정했고 Weapon_IN 애니메이션을 각 무기마다 추가 시켰다. WeaponManager를 수정했고 쓸모가 없었던 WeaponSway 스크립트를 제거했다
무기마다 HUD를 다르게 할 수 있도록 수정했고 총알이 실시간으로 변하는 함수를 만들었다.
2. 지역 / 지형 추가하기
// 못했다.
3. 콜렉션 Item화 시키기
// Potion은 item화 시켜서 인벤토리에 정확하게 집어넣었으나 콜렉션은 아직 전용 메뉴창을 생성하지 않아서 추가시키지 않았다.

오늘의 알고리즘 문제 : 없음 - 당분간은 C++ 문제 중단
----------------------------------------------------
----------------------------------------------------

0603.
1. 지형 추가하기	
// 실패
2. ESC 메뉴창 생성
// 성공했으나 부분적으로 수정해야할 부분이 많음.
// 세이브, 로드를 해보았고 추가적으로 더 추가하거나 해야할듯
// 옵션부분은 가장 마지막에 할 생각.
3. 콜렉션 전용 메뉴창 UI 생성
// 성공했으나 부분적으로 수정해야할 부분이 많음. 
// 이미지를 누르면 이미지에대한 ui를 호출시키고 아이템에 대한 자세한 스토리와 이미지를 보여주도록 할것입니다.

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0604.
1. 아이템 수집 시스템 프로토타입 완성시키기
// 완성! 이제 아이템 여러가지 추가시키면 된다! 아이템이 필요할때마다 생성해주자!
// 나중에 최적화 단계에 들어섰을 때 상속걸어서 중복되는 함수들을 처리해서 메모리
// 를 관리하자!!
2. 지형 추가하기
// 실패!!
3. 인벤토리 추가 기능 건설하기
// 어떤거 하려고 했는지 기억 안남, 드래그 문제는 해결했음

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0605.
1. 콜렉션 인포메이션 UI를 완성시키기
// 완성! 이제 아이템 사용만 할 줄 알면 완전히 끝이다!!
2. 지형 추가하기 // 실패!! 앜
3. 콜렉션 클래스들 상속시키기
// 자식 클래스마다 필요한 함수를 부모 클래스의 가상함수를 가져와 생성
// abstract override 성공
// 포션 아이템을 사용할 수 있게 되었다!
// 도감 시스템을 저장해서 사용할 수 있게 되었다!

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0608.
1.지형 추가하기
// 실패
2.저장하고 불러올 때 세이브 시점에 획득했었던 아이템을 Destroy시키기
// 아무리 생각해도 답이 안나온다 나중에 하자
3.콜렉션 창을 드래그해서 이동시켜보자
// 해당 UI의 pivot에 마우스가 자꾸 가는데 이 문제를 해결하지 못해서 마지막으로 미룸
4.인벤토리 퀵슬롯으로 사용하기
// 4번부터 순서대로 쓸수있도록 하겠다.
// 지금은 4, 5번까지만 구현했다~ 어차피 복붙하면되니 문제x

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0609.
1. 지형 추가하기
// 추가 했으나 시간 너무 날려먹음
2. 스토리 확정짓기
// 확정했음
-- 스토리 초안 --
// 1. 총을 가지고 과거와 현재 미래를 드나든다는 컨셉
1-1. 중세시대로 가서 성을 함락시키고
1-2. 미래시대로 가서 우주선을 정복하고
1-3. 현재시대로 와서 현재를 산다는.. 내용 // 

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0610.
1.지형 추가하기
// 실패
2.오브젝트 Action스크립트 완전히 작동시키기
// 각 상호작용 객체마다 isAcquired 및 isOpen 등의 진리값을 주고
// 그걸 통해서 객체들의 상황 및 상태를 구분지어 관리함.
// 작동 성공

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0611.
1. 지형 추가하기
// 실패
2. 물약 사용 파티클 생성
// 파티클을 한 번 간이로 만들어봤다. 나름 재밌음
3. 미닫이 문 트리거 생성
// 성공, Bacting Static이 켜져있으면 애니메이션이 작동하지 않는다는걸 배웠음,
4. 문 개폐 조건 생성
// 실패
5. 상황에 따른 스크립트 클래스 생성
// 성공, 이제 스크립트가 필요한 클래스에서 해당 클래스를 호출해서 사용이 가능하다.


오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0612.
1. 지형 추가하기
// 실패
2. 방 탈출 트리거 설치
// 손전등을 주워야만 스위치의 트리거가 작동되도록 구현해놓았다.
3. 문 개폐 조건 생성
// 열쇠가 없으면 열수 없도록 해놓았음.
4. 열쇠 및 다른 아이템 생성
// 열쇠 아이템밖에 생성 못함, 다음엔 맵 스타일에 맞는 아이템을 생성할 예정

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0615.
1. 사운드 추가하기
// 가구들 사운드 웬만한건 다 넣었습니다. 문, 수납장, 아이템 줍기, 의자 드래깅 등
2. 트리거 추가하기
// 통과할수 있는 문을 열기 위해서는 단서와 열쇠가 필요하도록 만들었습니다.
// 순차적으로 문을 열 수 있도록 하겠습니다.
// 생각해본 결과 조작법 UI를 따로 만들어서 esc를 눌러서 선택하면
// 볼수 있도록 하면 좋을 것 같습니다.

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0616.
1. 사운드 추가하기
// 이것저것 추가하긴 했지만 아직 많이 부족하다.
2. 트리거 추가하기
// 제발 트리거좀 추가하자!! 그리고 스토리도좀 
3. 커신 추가하기(실제로 등장하지 않더라도 실루엣만이라도)
// 실패~!
4. 조작법 UI 생성
// 성공!! 

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0617.
1. 사운드 추가하기
2. 트리거 추가하기
3. 커신 추가하기

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0618.
1. 세이브로드 수정하기
// 미완, 내일 마저 완성
2. 트리거 수정하기
// 완료
3. 기획서 작성
// 했음 내일 추가수정

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0619.
1.기획서 수정
// 발표 끝
2.트리거 추가
// 성공했으나 미약
3.첫 번째 스테이지(방) 완성시키고 다음 스테이지로 이동시키기
// 실패

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0620. 토요일
1. 단서 획득 시 Information UI 오픈
// 성공, 획득 함수에 추가만해주면 됐음.
2. 방 추가하기
// 실패, 일요일날 해보자 제발, 스토리가 안나온다
3. AudioMixer로 SoundManager 관리
// 효과음, 배경음으로 채널을 나눴음, 옵션창에 슬라이더로 조절할수있게 구현함.

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0621. 일요일
1. 사운드 추가하기
// 유리 깨지는 소리 추가, 패닉 브리쓰 다용도로 사용.
2. 트리거 추가하기
// 유리 깨지는 트리거 추가했음. 화장실 문 열리는 트리거랑
3. 아이템 추가하기 스토리 변경하기
// 스토리 걍 대충 만들기로함. 노트도 하나 만들어서 트리거에 껴놈.
4. 딕셔너리로 자원소모 최소화하기
// Resources.Load는 자원소모가 심하다고한다. 그래서 한 번 소환한 객체는 소환해둔 다음 딕셔너리에 저장시켜놓고 다음에 쓸 때는 딕셔너리에 저장시켜둔 객체를 리턴시킨다. 다른 곳에도 응용 가능하다고 함.

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0622. 월요일
1. 1스테이지 트리거 완성하기
// 반반.. 엔딩은 아직 안만들었음. tv도 코루틴 수정해야함. 반복이 계속 될 수 있도록 하고 싶음.
2. 책 스토리 추가하기.
// 성공, 대신 글씨체가 잘 보이는진 모르겠음.

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0623.
1. 첫번째방 엔딩만들기
// 성공, 좀 미약 추후 수정
2. 두번째방 구성하기
// 첫번쨰 까지만 하기로 함
3. 시네머신 사용해보기
// 돌리 트랙 & 카메라 배움

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0624.
1. 팀포폴 분할업무 배정
// 그래픽 맡기로함. Particle 및 Shader 관련해서 공부좀 해야겠음.
2. 게임 마무리 작업함
// 이제 Logo만 달면 포폴준비완료

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0625.
1. 개인 포트폴리오 마무리 작업
// 로고 만들어서 추가했고, 엔딩보고나면 메인으로 가도록 수정했음, 영상은 아마 내일 // 찍고 자막 달아야 할듯.
2. VFX 및 Shuriken 만져보기
// 슈리켄은 할만하다. vfx는 좀 더 알아보자

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0626.
1. Shuriken 및 VFX 만져보기
// 짜잘짜잘한 이펙트 만듬,

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0629.
1. Shuriken 및 VFX로 파티클 제작하기
2. 개인 포트폴리오 영상 제작

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0630.
1. Shuriken 및 VFX 작업하기
2. 복셀 게임에 어울릴만한 파티클 찾아보기
// 마인크래프트 던전스에 나오는 파티클 위주로 제작해보면 될듯하다.
3. 포트폴리오 영상 자막 넣기
// 성공.

-VFX는 미학적인 요소를 추가할때 용이하고 저사양으로 하이엔드 성능을 나타내기에 용이함.
왜냐하면 VFX는 CPU가 아닌 GPU를 사용하기때문에 그리고 모바일에는 적절하지 않은듯.
-Shuriken은 게임 상의 오브젝트들과 상호작용이 필요할 때 사용한다. Shuriken은 CPU를 사용함.
ex) 총알, 빔, 검기 등

- 파티클 마테리얼 쉐이더를 Mobile/Particles/ 로 바꿀것.
- 내가 원하는 색이 안나올 경우에만 Legacy Shader/Particles 로 마테리얼 제작
- SetPassCall 차이가 있긴 하다.

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0701.
1. VFX 및 Shuriken으로 파티클 제작하기
// Spark 및 Aura 등 제작했음.
2. 팀 포트폴리오 시작

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0702.
1. VFX 및 Shuriken으로 파티클 제작하기
// 블리딩 효과, 이동거리마다 파티클 생성하는 이펙트, 폭발 효과
2. 에프터 이펙트 사용
// 플레이어 및 몬스터가 사용해야할 Slash 텍스쳐 제작 및 적용

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
---------------------------------------------------- 

0703.
1. VFX 및 Shuriken으로 파티클 제작하기
// 아이템 드랍, 획득 UI 이펙트 제작
2. 파티클 적용 알고리즘 및 코드 작성(상황에 따라)
// 벡터 내적 구해봤음

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
---------------------------------------------------- 

0706.
1. VFX 및 Shuriken으로 파티클 제작하기
// 토네이도 따라서 만들어봤슴다
2. 오브젝트 풀링 기법 사용해서 투사체 및 파티클 관리해보기
// 투사체 오브젝트 풀 제작해봤습니다.

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0707.
1. VFX 및 Shuriken으로 파티클 제작하기
// 액체를 표현하는 TextureSheet 텍스쳐를 가져와서 물이 튀는 것 같은 느낌으로
// 만들었는데 어떤진 모르겠다.
2. 파티클 오브젝트 풀링 기법 사용해서 구현해보기
// 몬스터, 플레이어들이 오브젝트 풀에서 가져와서 쏠 수 있도록 프로토타입 만들어보기
// 간단하게 1번 2번 눌러서 투척하게 해놨고 부모 객체의 LocalRotation에 따라
// 투사체가 발사될 수 있도록 했음.
// 전체 파티클 관리는 좀 천천히 봐가면서 써야할 듯.

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0708.
1. VFX 및 Shuriken으로 파티클 제작하기
// 마그마 만들려다가 피 같은거 만들어버림
2. UI 그래픽 적용 및 인벤토리 초안 제작
// 인벤토리는 안해봤고 UI는 유니티에 적용함
3. 섬 검사 알고리즘 짜보기
// 영규씨가 완성함

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0709.
1. VFX 및 Shuriken으로 파티클 제작하기
// 색상 수정만 했음
2. UI 그래픽 적용 및 인벤토리 초안 제작
// 만듬

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0710.
1. 인벤토리 & 콜렉션 제작
// 콜렉션 다음에 인벤토리는 완료
2. UI 적용
// 받은 디자인 UI 로 적용

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0713.
1. 도감 제작
// 유물 도감에 적용했음

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0714.
1. 도감 마무리
// 도검, 유물 연동 끝마침
2. 아이템 기능 구현 및 파티클 제작
// 이펙트 트레일 간이로 제작해봄
3. UI 적용
// 마켓 UI, 캐릭터 UI, 도감 UI, 최신 이미지로 수정함.

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0715.
1. 도검 획득 시 디자인 변경
// 도검 획득 시 오브젝트 변경하는거 했음. 코드가 좀 이상한 것같지만 나중에 최적화 단계때
// 찾아보고 수정할 거 있으면 수정하는 걸로.
2. VFX 및 Shuriken으로 파티클 제작
// 안만듬
3. UI 보수
// 검 조각 UI는 이미지 좌표를 기억해서 해당 좌표에 이미지를 넣자.
4. 아이템 기능 스크립트 제작
// 다음에

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0716.
1. VFX 및 Shuriken으로 파티클 제작
// 다음 주부터 빡세게 만듬
2. UI 보수
// UI 수정
3. 아이템 기능 스크립트 제작
// 내일 해보자
4. 도검 획득 시 검 조각 UI 변경
// 검 조각, 오브젝트 변경까지 완료.
// 이제 본 게임 들어가서 세세한 부분 수정 및 추가 하면 될듯.

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0717.
1. VFX 및 Shuriken으로 파티클 제작
// 검기 이펙트 연구!!
2. UI 보수
// 보수보수
3. 아이템 기능 스크립트 제작
// 일단 함수들만 만들어놓음.

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0720.
1. VFX 및 Shuriken으로 파티클 제작
// 안만듬
2. UI 보수
// 몬스터 컬렉션 해야함
3. 아이템 기능 스크립트 제작
// 보류
4. 인벤토리 json화

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0721.
1. VFX 및 Shuriken으로 파티클 제작
// 안함
2. UI 보수
// 카드뽑는거 만듬
3. 아이템 기능 스크립트 제작
// 아직 안만듬
4. 세이브 로드 기능 제작
// 인벤토리, 도감만 해놓음

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0722.
1. VFX 및 Shuriken으로 파티클 제작
// 안함
2. UI 보수
// 안함
3. 플레이어 애니메이션 변경
// 애니메이션 컨트롤러를 무기를 바꿀때마다 변경해줌

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0723.
1. VFX 및 Shuriken으로 파티클 제작
// 야스오 Q 간단하게 만들어봄. 어제 만든 BF_SLASH 재활용 해서 카타나 평타 및 스킬을 완성하자
2. UI 보수
// UI는 이제 추가할 일만 남았다, 도감 확인 중일 때 책갈피 못누르게만 하자
// 슬라이더도 추가
3. 인벤토리, 도감, 세이브 보수
// 베타 버전 정상 작동

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0724.
1. VFX 및 Shuriken으로 파티클 제작
// 야스오 q 간이 제작
2. UI 보수
3. 도검 애니메이션 제작
// 도검 애니메이터 컨트롤러를 하나로 통합해서 사용하기로 결정.
// Layer를 쓸것인지 다른 방법을 사용할 것인지는 추후 고려.
// 애니메이션 클립을 가져와 쓰는 방법도 있다.

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0727.
1. VFX 및 Shuriken으로 파티클 제작
2. 아이템 기능 제작
3. 파티클 적용

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0728.
1. VFX 및 Shuriken으로 파티클 제작
// 담에 다시
2. 검 조각 획득 시 기능 적용
// 함수는 작성해두었음.
3. 팝업 UI 생성 ( ESC누르면 나가시겠습니까? AND CARD 클릭시 정보 출력 및 선택 재확인)
// 내일 마저 하기

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------
 
0729.
1. Shuriken으로 파티클 제작
// 안함
2. 팝업 UI 생성
// esc 누르면 나가기 팝업 ui 생성, 검 선택 가능하게.

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0730.
1. Shuriken으로 파티클 제작

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0731.
1. 인디케이터 만들어보기
2. 퀘스트 만들어보기
3. 팀포폴

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------

0806.
1. 인벤토리 세이브 정상작동시키기
2. 파티클 적용해보기 

오늘의 알고리즘 문제 : 없음
----------------------------------------------------
----------------------------------------------------
